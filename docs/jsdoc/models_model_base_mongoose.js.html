<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>models/model_base_mongoose.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="JrResult.JrContext.html">JrContext</a></li><li><a href="JrResult.JrResult.html">JrResult</a></li><li><a href="module-client_arclient-AppRoomClient.html">AppRoomClient</a></li><li><a href="module-controllers_aclaid-AclAid.html">AclAid</a></li><li><a href="module-controllers_adminaid-AdminAid.html">AdminAid</a></li><li><a href="module-controllers_arserver-AppRoomServer.html">AppRoomServer</a><ul class='methods'><li data-type='method'><a href="module-controllers_arserver-AppRoomServer.html#emergencyAlert">emergencyAlert</a></li><li data-type='method'><a href="module-controllers_arserver-AppRoomServer.html#makeSecureTokenAccess">makeSecureTokenAccess</a></li><li data-type='method'><a href="module-controllers_arserver-AppRoomServer.html#makeSecureTokenAccessFromRefreshToken">makeSecureTokenAccessFromRefreshToken</a></li><li data-type='method'><a href="module-controllers_arserver-AppRoomServer.html#makeSecureTokenRefresh">makeSecureTokenRefresh</a></li></ul></li><li><a href="module-controllers_crudaid-CrudAid.html">CrudAid</a></li><li><a href="module-controllers_registrationaid-RegistrationAid.html">RegistrationAid</a></li><li><a href="module-controllers_sendaid-SendAid.html">SendAid</a><ul class='methods'><li data-type='method'><a href="module-controllers_sendaid-SendAid.html#sendMail">sendMail</a></li><li data-type='method'><a href="module-controllers_sendaid-SendAid.html#sendMessage">sendMessage</a></li></ul></li><li><a href="module-controllers_setupaid-SetupAid.html">SetupAid</a></li><li><a href="module-helpers_jrresult-JrResult.html">JrResult</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#._unusedCodeExpressMiddlewareInjectSessionResult">_unusedCodeExpressMiddlewareInjectSessionResult</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.isBlank">isBlank</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.isJrResult">isJrResult</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.makeClone">makeClone</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.makeError">makeError</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.makeMessage">makeMessage</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.makeNew">makeNew</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.makeSuccess">makeSuccess</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.passportOrJrResultErrorAsString">passportOrJrResultErrorAsString</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.retrieveThenRemoveFromSession">retrieveThenRemoveFromSession</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#.undefinedIfBlank">undefinedIfBlank</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#addToSession">addToSession</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#clear">clear</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#clearSection">clearSection</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#copyFrom">copyFrom</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#getErrorsAsString">getErrorsAsString</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#getExtraData">getExtraData</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#getFieldError">getFieldError</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#getSuccessAsString">getSuccessAsString</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#getType">getType</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#isError">isError</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#mergeIn">mergeIn</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#mergeInThenRemoveFromSession">mergeInThenRemoveFromSession</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#push">push</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#pushBiFieldError">pushBiFieldError</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#pushError">pushError</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#pushErrorOnTop">pushErrorOnTop</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#pushException">pushException</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#pushFieldError">pushFieldError</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#pushMessage">pushMessage</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#pushSuccess">pushSuccess</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#setError">setError</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#setExtraData">setExtraData</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#setFieldError">setFieldError</a></li><li data-type='method'><a href="module-helpers_jrresult-JrResult.html#setType">setType</a></li></ul></li><li><a href="module-models_app-AppModel.html">AppModel</a></li><li><a href="module-models_connection-ConnectionModel.html">ConnectionModel</a></li><li><a href="module-models_file-FileModel.html">FileModel</a></li><li><a href="module-models_login-LoginModel.html">LoginModel</a></li><li><a href="module-models_log-LogModel.html">LogModel</a></li><li><a href="module-models_model_base_mongoose_minimal-ModelBaseMongooseMinimal.html">ModelBaseMongooseMinimal</a></li><li><a href="module-models_modelBaseMongoose-ModelBaseMongoose.html">ModelBaseMongoose</a><ul class='methods'><li data-type='method'><a href="module-models_modelBaseMongoose-ModelBaseMongoose.html#.doChangeModeById">doChangeModeById</a></li><li data-type='method'><a href="module-models_modelBaseMongoose-ModelBaseMongoose.html#doChangeMode">doChangeMode</a></li></ul></li><li><a href="module-models_modqueue-ModQueueModel.html">ModQueueModel</a></li><li><a href="module-models_option-OptionModel.html">OptionModel</a></li><li><a href="module-models_option-RoleModel.html">RoleModel</a></li><li><a href="module-models_roomdata-RoomdataModel.html">RoomdataModel</a></li><li><a href="module-models_room-RoomModel.html">RoomModel</a></li><li><a href="module-models_session-SessionModel.html">SessionModel</a></li><li><a href="module-models_subscription-SubscriptionModel.html">SubscriptionModel</a></li><li><a href="module-models_user-UserModel.html">UserModel</a><ul class='methods'><li data-type='method'><a href="module-models_user-UserModel.html#aclHasPermission">aclHasPermission</a></li><li data-type='method'><a href="module-models_user-UserModel.html#aclHasPermissionOnAll">aclHasPermissionOnAll</a></li><li data-type='method'><a href="module-models_user-UserModel.html#aclHasPermissionSeeVDeletes">aclHasPermissionSeeVDeletes</a></li></ul></li><li><a href="module-models_verification-VerificationModel.html">VerificationModel</a></li></ul><h3>Modules</h3><ul><li><a href="module-arglobals.html">arglobals</a><ul class='methods'><li data-type='method'><a href="module-arglobals.html#~setupDefaultModulePaths">setupDefaultModulePaths</a></li></ul></li><li><a href="module-client_arclient.html">client/arclient</a><ul class='methods'><li data-type='method'><a href="module-client_arclient.html#~makeNewAppRoomClient">makeNewAppRoomClient</a></li></ul></li><li><a href="module-clientTests.html">clientTests</a></li><li><a href="module-controllers_aclaid.html">controllers/aclaid</a></li><li><a href="module-controllers_adminaid.html">controllers/adminaid</a></li><li><a href="module-controllers_appdef.html">controllers/appdef</a></li><li><a href="module-controllers_arserver.html">controllers/arserver</a></li><li><a href="module-controllers_crudaid.html">controllers/crudaid</a></li><li><a href="module-controllers_jrequireaid.html">controllers/jrequireaid</a><ul class='methods'><li data-type='method'><a href="module-controllers_jrequireaid.html#~setDeferredLoading">setDeferredLoading</a></li><li data-type='method'><a href="module-controllers_jrequireaid.html#~setupDefaultModulePaths">setupDefaultModulePaths</a></li></ul></li><li><a href="module-controllers_registrationaid.html">controllers/registrationaid</a></li><li><a href="module-controllers_sendaid.html">controllers/sendaid</a></li><li><a href="module-controllers_setupaid.html">controllers/setupaid</a></li><li><a href="module-helpers_jrconfig.html">helpers/jrconfig</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrconfig.html#~addConfigFile">addConfigFile</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~addConfigFilesCli">addConfigFilesCli</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~configAutoConverTypeVal">configAutoConverTypeVal</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~discoverConfigFiles">discoverConfigFiles</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~doNconfFile">doNconfFile</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~findQueuedCommand">findQueuedCommand</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~fixConfigFilePathName">fixConfigFilePathName</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~getDebugFiles">getDebugFiles</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~getDebugHierarchy">getDebugHierarchy</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~getDebugOptions">getDebugOptions</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~getVal">getVal</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~getValDefault">getValDefault</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~ipStringToSafeFilenameString">ipStringToSafeFilenameString</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~nconfMergeConfigFile">nconfMergeConfigFile</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~parse">parse</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~popQueuedCommand">popQueuedCommand</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~queueYargsCommand">queueYargsCommand</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~runQueuedCommands">runQueuedCommands</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~setConfigDirs">setConfigDirs</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~setDefaultOptions">setDefaultOptions</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~setEnvList">setEnvList</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~setOverrideOptions">setOverrideOptions</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~setServerFilenamePrefixFromServerIp">setServerFilenamePrefixFromServerIp</a></li><li data-type='method'><a href="module-helpers_jrconfig.html#~setYargs">setYargs</a></li></ul></li><li><a href="module-helpers_jrcontext.html">helpers/jrcontext</a></li><li><a href="module-helpers_jrdebug.html">helpers/jrdebug</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrdebug.html#~cdebug">cdebug</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~cdebugf">cdebugf</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~cdebugObj">cdebugObj</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~debug">debug</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~debugf">debugf</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~debugObj">debugObj</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~debugObj2">debugObj2</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~getDebugTagEnabled">getDebugTagEnabled</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~setDebugTagEnabled">setDebugTagEnabled</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~setup">setup</a></li><li data-type='method'><a href="module-helpers_jrdebug.html#~setupDebugmod">setupDebugmod</a></li></ul></li><li><a href="module-helpers_jrequire.html">helpers/jrequire</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrequire.html#~calcDebugInfo">calcDebugInfo</a></li><li data-type='method'><a href="module-helpers_jrequire.html#~fixRequirePath">fixRequirePath</a></li><li data-type='method'><a href="module-helpers_jrequire.html#~jrequire">jrequire</a></li><li data-type='method'><a href="module-helpers_jrequire.html#~registerPath">registerPath</a></li><li data-type='method'><a href="module-helpers_jrequire.html#~registerRequire">registerRequire</a></li><li data-type='method'><a href="module-helpers_jrequire.html#~setDeferredLoading">setDeferredLoading</a></li></ul></li><li><a href="module-helpers_jrh_axios.html">helpers/jrh_axios</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_axios.html#~calcAxiosOptions">calcAxiosOptions</a></li><li data-type='method'><a href="module-helpers_jrh_axios.html#~getCatchError">getCatchError</a></li><li data-type='method'><a href="module-helpers_jrh_axios.html#~postAxiosGetResponseDataCatchError">postAxiosGetResponseDataCatchError</a></li></ul></li><li><a href="module-helpers_jrh_crypto.html">helpers/jrh_crypto</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_crypto.html#~createHashedObjectFromString">createHashedObjectFromString</a></li><li data-type='method'><a href="module-helpers_jrh_crypto.html#~generateRandomSalt">generateRandomSalt</a></li><li data-type='method'><a href="module-helpers_jrh_crypto.html#~genRandomStringFromCharSet">genRandomStringFromCharSet</a></li><li data-type='method'><a href="module-helpers_jrh_crypto.html#~genRandomStringHex">genRandomStringHex</a></li><li data-type='method'><a href="module-helpers_jrh_crypto.html#~genRandomStringHumanEasier">genRandomStringHumanEasier</a></li><li data-type='method'><a href="module-helpers_jrh_crypto.html#~genRandomStringHumanEasy">genRandomStringHumanEasy</a></li><li data-type='method'><a href="module-helpers_jrh_crypto.html#~hashPlaintextPasswordToObj">hashPlaintextPasswordToObj</a></li><li data-type='method'><a href="module-helpers_jrh_crypto.html#~hashPlaintextStringInsecureButSearchable">hashPlaintextStringInsecureButSearchable</a></li><li data-type='method'><a href="module-helpers_jrh_crypto.html#~testPlaintextPassword">testPlaintextPassword</a></li></ul></li><li><a href="module-helpers_jrh_express.html">helpers/jrh_express</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_express.html#~asyncPassportAuthenticate">asyncPassportAuthenticate</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~asyncPassportReqLogin">asyncPassportReqLogin</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~calcExpressMiddleWare">calcExpressMiddleWare</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~calcExpressMiddlewareGetFileLine">calcExpressMiddlewareGetFileLine</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~calcExpressMiddlewareRouterHint">calcExpressMiddlewareRouterHint</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~calcExpressRoutePathData">calcExpressRoutePathData</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~calcExpressRoutePathDataRouteArray">calcExpressRoutePathDataRouteArray</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~calcExpressRoutePathDataSplit">calcExpressRoutePathDataSplit</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~forgetSessionVar">forgetSessionVar</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~normalizePort">normalizePort</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~parseReqGetJsonField">parseReqGetJsonField</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~reqOriginalUrl">reqOriginalUrl</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~reqPrefixedCheckboxItemIds">reqPrefixedCheckboxItemIds</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~reqPrefixedValueArray">reqPrefixedValueArray</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~reqUrlWithPath">reqUrlWithPath</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~reqVal">reqVal</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~reqValAsInt">reqValAsInt</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~reqValFromList">reqValFromList</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~sendJsonDataSuccess">sendJsonDataSuccess</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~sendJsonErorrAcl">sendJsonErorrAcl</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~sendJsonError">sendJsonError</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~sendJsonErrorAuthToken">sendJsonErrorAuthToken</a></li><li data-type='method'><a href="module-helpers_jrh_express.html#~sendJsonResult">sendJsonResult</a></li></ul></li><li><a href="module-helpers_jrh_grid.html">helpers/jrh_grid</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_grid.html#~calcHeaderKeysNicely">calcHeaderKeysNicely</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridList">jrGridList</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListBulkActions">jrGridListBulkActions</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListPager">jrGridListPager</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListPagerItem">jrGridListPagerItem</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListPagerItemPerPage">jrGridListPagerItemPerPage</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListShowHiddenOptions">jrGridListShowHiddenOptions</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListTable">jrGridListTable</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListTableData">jrGridListTableData</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListTableHeader">jrGridListTableHeader</a></li><li data-type='method'><a href="module-helpers_jrh_grid.html#~jrGridListTableHeaderSortDir">jrGridListTableHeaderSortDir</a></li></ul></li><li><a href="module-helpers_jrh_handlebars.html">helpers/jrh_handlebars</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_handlebars.html#~loadPartialFiles">loadPartialFiles</a></li><li data-type='method'><a href="module-helpers_jrh_handlebars.html#~setupJrHandlebarHelpers">setupJrHandlebarHelpers</a></li></ul></li><li><a href="module-helpers_jrh_misc.html">helpers/jrh_misc</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_misc.html#~asyncAwaitForEachFunctionCall">asyncAwaitForEachFunctionCall</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~asyncAwaitForEachObjectKeyFunctionCall">asyncAwaitForEachObjectKeyFunctionCall</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~asyncNextTick">asyncNextTick</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~copyMissingValues">copyMissingValues</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~createObjectFromJsonParse">createObjectFromJsonParse</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~DateNowPlusMinutes">DateNowPlusMinutes</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~deepIterationCopy">deepIterationCopy</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~ErrorToHashableMapObject">ErrorToHashableMapObject</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~findLongestPrefixAndRemainder">findLongestPrefixAndRemainder</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~firstCoercedTrueValue">firstCoercedTrueValue</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getCompactNowString">getCompactNowString</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getNiceDateValString">getNiceDateValString</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getNiceDurationTimeMs">getNiceDurationTimeMs</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getNiceNowString">getNiceNowString</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getNonFalseValueOrDefault">getNonFalseValueOrDefault</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getNonNullValueFromObject">getNonNullValueFromObject</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getNonNullValueOrDefault">getNonNullValueOrDefault</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getPreciseNowString">getPreciseNowString</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~getServerIpAddress">getServerIpAddress</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~isInAnyArray">isInAnyArray</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~isObjectEmpty">isObjectEmpty</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~isObjectHashMappableType">isObjectHashMappableType</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~isPromise">isPromise</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~isSimpleObject">isSimpleObject</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~makeSafeForFormInput">makeSafeForFormInput</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~mergeArraysDedupe">mergeArraysDedupe</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~mergeArraysKeepDupes">mergeArraysKeepDupes</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~objectHasProperty">objectHasProperty</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~objToString">objToString</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~objToString2">objToString2</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~regexEscapeStr">regexEscapeStr</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~resolvePossiblyRelativeDirectory">resolvePossiblyRelativeDirectory</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~shallowCopy">shallowCopy</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~stringArrayToNiceString">stringArrayToNiceString</a></li><li data-type='method'><a href="module-helpers_jrh_misc.html#~usleep">usleep</a></li></ul></li><li><a href="module-helpers_jrh_mongo.html">helpers/jrh_mongo</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_mongo.html#~calcDatabaseInfo">calcDatabaseInfo</a></li><li data-type='method'><a href="module-helpers_jrh_mongo.html#~calcDatabaseStructure">calcDatabaseStructure</a></li><li data-type='method'><a href="module-helpers_jrh_mongo.html#~convertArrayOfObjectIdsToIdArray">convertArrayOfObjectIdsToIdArray</a></li><li data-type='method'><a href="module-helpers_jrh_mongo.html#~isValidMongooseObjectId">isValidMongooseObjectId</a></li><li data-type='method'><a href="module-helpers_jrh_mongo.html#~OldUnusedMongoIdEqual">OldUnusedMongoIdEqual</a></li></ul></li><li><a href="module-helpers_jrh_mongo_filter.html">helpers/jrh_mongo_filter</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_mongo_filter.html#~buildMongooseQueryFromReq">buildMongooseQueryFromReq</a></li><li data-type='method'><a href="module-helpers_jrh_mongo_filter.html#~convertReqQueryStringToAMongooseFindFilter">convertReqQueryStringToAMongooseFindFilter</a></li><li data-type='method'><a href="module-helpers_jrh_mongo_filter.html#~convertReqQueryStringToAMongooseFindFilterBoolean">convertReqQueryStringToAMongooseFindFilterBoolean</a></li><li data-type='method'><a href="module-helpers_jrh_mongo_filter.html#~convertReqQueryStringToAMongooseFindFilterGenericOperator">convertReqQueryStringToAMongooseFindFilterGenericOperator</a></li><li data-type='method'><a href="module-helpers_jrh_mongo_filter.html#~convertReqQueryStringToAMongooseFindFilterGenericOperatorResolveVal">convertReqQueryStringToAMongooseFindFilterGenericOperatorResolveVal</a></li><li data-type='method'><a href="module-helpers_jrh_mongo_filter.html#~convertReqQueryStringToAMongooseFindFilterMongoStrCmp">convertReqQueryStringToAMongooseFindFilterMongoStrCmp</a></li><li data-type='method'><a href="module-helpers_jrh_mongo_filter.html#~convertReqQueryStringToAMongooseFindFilterNumeric">convertReqQueryStringToAMongooseFindFilterNumeric</a></li><li data-type='method'><a href="module-helpers_jrh_mongo_filter.html#~convertReqQueryStringToAMongooseFindFilterStringic">convertReqQueryStringToAMongooseFindFilterStringic</a></li></ul></li><li><a href="module-helpers_jrh_ratelimiter.html">helpers/jrh_ratelimiter</a></li><li><a href="module-helpers_jrh_text.html">helpers/jrh_text</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_text.html#~capitalizeFirstLetter">capitalizeFirstLetter</a></li><li data-type='method'><a href="module-helpers_jrh_text.html#~jrBootstrapCollapseBox">jrBootstrapCollapseBox</a></li><li data-type='method'><a href="module-helpers_jrh_text.html#~jrHtmlFormInputPassword">jrHtmlFormInputPassword</a></li><li data-type='method'><a href="module-helpers_jrh_text.html#~jrHtmlFormOptionList">jrHtmlFormOptionList</a></li><li data-type='method'><a href="module-helpers_jrh_text.html#~jrHtmlFormOptionListSelect">jrHtmlFormOptionListSelect</a></li><li data-type='method'><a href="module-helpers_jrh_text.html#~jrHtmlNiceOptionFromList">jrHtmlNiceOptionFromList</a></li><li data-type='method'><a href="module-helpers_jrh_text.html#~jrHtmlStrigifyObject">jrHtmlStrigifyObject</a></li><li data-type='method'><a href="module-helpers_jrh_text.html#~jrPluralize">jrPluralize</a></li><li data-type='method'><a href="module-helpers_jrh_text.html#~jrPluralizeCount">jrPluralizeCount</a></li></ul></li><li><a href="module-helpers_jrh_validate.html">helpers/jrh_validate</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrh_validate.html#~validateInteger">validateInteger</a></li><li data-type='method'><a href="module-helpers_jrh_validate.html#~validateIntegerRange">validateIntegerRange</a></li><li data-type='method'><a href="module-helpers_jrh_validate.html#~validateJsonObjOrStringToObj">validateJsonObjOrStringToObj</a></li><li data-type='method'><a href="module-helpers_jrh_validate.html#~validateRealName">validateRealName</a></li><li data-type='method'><a href="module-helpers_jrh_validate.html#~validateString">validateString</a></li><li data-type='method'><a href="module-helpers_jrh_validate.html#~validateTrueFalse">validateTrueFalse</a></li></ul></li><li><a href="module-helpers_jrlog.html">helpers/jrlog</a><ul class='methods'><li data-type='method'><a href="module-helpers_jrlog.html#~aliasWinstonLogger">aliasWinstonLogger</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~calcLogFilePath">calcLogFilePath</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~createLogFileObj">createLogFileObj</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~createWinstonLoggerObject">createWinstonLoggerObject</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~getWinstonCategoryLogger">getWinstonCategoryLogger</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~log">log</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~logDefaultError">logDefaultError</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~logExceptionError">logExceptionError</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~logExceptionErrorWithMessage">logExceptionErrorWithMessage</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~logMessage">logMessage</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~logObject">logObject</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~setup">setup</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~setupMorganMiddlewareForExpressWebAccessLogging">setupMorganMiddlewareForExpressWebAccessLogging</a></li><li data-type='method'><a href="module-helpers_jrlog.html#~setupWinstonLogger">setupWinstonLogger</a></li></ul></li><li><a href="module-helpers_jrresult.html">helpers/jrresult</a></li><li><a href="module-models_app.html">models/app</a></li><li><a href="module-models_connection.html">models/connection</a></li><li><a href="module-models_file.html">models/file</a></li><li><a href="module-models_log.html">models/log</a></li><li><a href="module-models_login.html">models/login</a></li><li><a href="module-models_model_base_mongoose_minimal.html">models/model_base_mongoose_minimal</a></li><li><a href="module-models_modelBaseMongoose.html">models/modelBaseMongoose</a></li><li><a href="module-models_modqueue.html">models/modqueue</a></li><li><a href="module-models_option.html">models/option</a></li><li></li><li><a href="module-models_room.html">models/room</a></li><li><a href="module-models_roomdata.html">models/roomdata</a></li><li><a href="module-models_session.html">models/session</a></li><li><a href="module-models_subscription.html">models/subscription</a></li><li><a href="module-models_user.html">models/user</a></li><li><a href="module-models_verification.html">models/verification</a></li><li><a href="module-plugins_testplugin.html">plugins/testplugin</a></li><li></li><li></li><li><a href="module-routes_admin.html">routes/admin</a></li><li></li><li></li><li><a href="module-routes_analytics.html">routes/analytics</a></li><li><a href="module-routes_api_api.html">routes/api/api</a><ul class='methods'><li data-type='method'><a href="module-routes_api_api.html#~routerAllDos">routerAllDos</a></li><li data-type='method'><a href="module-routes_api_api.html#~routerAllHello">routerAllHello</a></li><li data-type='method'><a href="module-routes_api_api.html#~routerAllRefreshAccess">routerAllRefreshAccess</a></li><li data-type='method'><a href="module-routes_api_api.html#~routerAllReqRefreshSession">routerAllReqRefreshSession</a></li><li data-type='method'><a href="module-routes_api_api.html#~routerAllTokenTest">routerAllTokenTest</a></li><li data-type='method'><a href="module-routes_api_api.html#~routerGetIndex">routerGetIndex</a></li><li data-type='method'><a href="module-routes_api_api.html#~routerGetReqRefreshCredentials">routerGetReqRefreshCredentials</a></li><li data-type='method'><a href="module-routes_api_api.html#~routerPostReqRefreshCredentials">routerPostReqRefreshCredentials</a></li><li data-type='method'><a href="module-routes_api_api.html#~setupRouter">setupRouter</a></li></ul></li><li><a href="module-routes_api_app.html">routes/api/app</a><ul class='methods'><li data-type='method'><a href="module-routes_api_app.html#~setupRouter">setupRouter</a></li></ul></li><li><a href="module-routes_api_roomdata.html">routes/api/roomdata</a><ul class='methods'><li data-type='method'><a href="module-routes_api_roomdata.html#~setupRouter">setupRouter</a></li><li data-type='method'><a href="module-routes_api_roomdata.html#~setupRouter">setupRouter</a></li></ul></li><li></li><li><a href="module-routes_app.html">routes/app</a></li><li></li><li><a href="module-routes_index.html">routes/index</a></li><li><a href="module-routes_login.html">routes/login</a></li><li><a href="module-routes_logout.html">routes/logout</a></li><li><a href="module-routes_membersonly.html">routes/membersonly</a></li><li><a href="module-routes_profile.html">routes/profile</a></li><li><a href="module-routes_register.html">routes/register</a></li><li><a href="module-routes_room.html">routes/room</a></li><li><a href="module-routes_verify.html">routes/verify</a></li><li><a href="module-serverTests.html">serverTests</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">models/model_base_mongoose.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module models/modelBaseMongoose
 * @author jesse reichler &lt;mouser@donationcoder.com>
 * @copyright 5/1/19
 * @description
 * The main base class we use to derive all database model objects
 * NOTE: Always be on the lookout for find queries that use the "lean" option to not instantiate full objects when querying database
 */

"use strict";


// modules
const mongoose = require("mongoose");


// requirement service locator
const jrequire = require("../helpers/jrequire");

// controllers
const arserver = jrequire("arserver");
const appdef = jrequire("appdef");

// our helper modules
const jrdebug = require("../helpers/jrdebug");
const jrhMisc = require("../helpers/jrh_misc");
const jrhMongo = require("../helpers/jrh_mongo");
const jrhText = require("../helpers/jrh_text");
const jrhValidate = require("../helpers/jrh_validate");
const jrhCrypto = require("../helpers/jrh_crypto");






/**
 *The main base class we use to derive all database model objects
 *
 * @class ModelBaseMongoose
 */
class ModelBaseMongoose {


	// CLASS data, which can be prolematic when we try to access from an instance (via getModelClass())
	// this.mongooseclass &lt;-- this is the one we get caught on as being undefined
	// this.crudBaseUrl
	// this.schema
	// this.modelSchema
	// this.modelObjPropertyList

	//---------------------------------------------------------------------------
	// subclasses implement these

	/*
	// global static version info
	static getVersion() { return 1; }

	// collection name for this model
	static getCollectionName() {
		return "basemodel";
	}

	// nice name for display
	static getNiceName() {
		return "BaseModel";
	}

	// name for acl lookup
	static getAclName() {
		return "basemodel";
	}

	// name for logging
	static getLoggingString() {
		return "Basemodel";
	}
	*/
	//---------------------------------------------------------------------------



	//---------------------------------------------------------------------------
	getModelClass() {
		// subclass overriding function that returns class instance (each subclass MUST implement this)
		// useful when we want to invoke a static function from instance.
		return ModelBaseMongoose;
	}
	//---------------------------------------------------------------------------




	//---------------------------------------------------------------------------
	static getBaseSchemaDefinition() {
		// some base schema properties for ALL models
		// this helps us keep track of some basic stuff for everything
		const UserModel = jrequire("models/user");
		return {
			_id: {
				label: "Id",
				readOnly: true,
				filterSize: 25,
				mongoose: {
					type: mongoose.Schema.ObjectId,
					auto: true,
				},
			},
			version: {
				label: "Ver.",
				readOnly: true,
				filterSize: 5,
				mongoose: {
					type: Number,
				},
			},
			creator: {
				label: "Creator",
				hide: true,
				valueFunction: this.makeModelValueFunctionObjectId(UserModel),
				mongoose: {
					type: mongoose.Schema.ObjectId,
				},
			},
			creationDate: {
				label: "Date created",
				// hide: true,
				readOnly: true,
				format: "date",
				mongoose: {
					type: Date,
				},
			},
			modificationDate: {
				label: "Date modified",
				readOnly: true,
				format: "date",
				mongoose: {
					type: Date,
				},
			},
			disabled: {
				label: "Disabled?",
				format: "choices",
				choices: appdef.DefStateModeLabels,
				choicesEdit: appdef.DefStateModeLabelsEdit,
				filterSize: 8,
				defaultValue: appdef.DefMdbEnable,
				mongoose: {
					type: Number,
				},
			},
			extraData: {
				label: "Extra data",
				valueFunction: this.makeModelValueFunctionExtraData(),
				filterSize: 0,
				mongoose: {
					type: mongoose.Mixed,
				},
			},
			notes: {
				label: "Notes",
				format: "textarea",
				mongoose: {
					type: String,
				},
			},
		};
	}
	//---------------------------------------------------------------------------



	//---------------------------------------------------------------------------
	// defaults for crud list
	static getCrudDefaults() {
		return {
			sortField: "_id",
			sortDir: "asc",
		};
	}

	// override this to default to real delete for some models
	static getDefaultDeleteDisableMode() {
		return appdef.DefMdbVirtDelete;
	}

	static getDefaultDeleteDisableModeIsVirtual() {
		return (this.getDefaultDeleteDisableMode() === appdef.DefMdbVirtDelete);
	}

	static supportsVirtualDelete() {
		return (this.getBaseSchemaDefinition().disabled !== undefined);
	}

	static getDefaultDeleteDisableModeAsAclAction() {
		const deleteDisableMode = this.getDefaultDeleteDisableMode();
		if (deleteDisableMode === appdef.DefMdbVirtDelete) {
			return appdef.DefAclActionDelete;
		}
		return appdef.DefAclActionPermDelete;
	}


	/**
	 * Should some user ACL own each instance?
	 * Subclasses can override this (rooms, apps) to say that there should be someone who OWNS this resource
	 *
	 * @static
	 * @returns true or false
	 * @memberof ModelBaseMongoose
	 */
	static getShouldBeOwned() {
		return false;
	}


	/**
	 * Should we log database actions on instances of this model?
	 * Subclasses can override this (logModel) to say that we shouldnt create log entries when they are deleted etc.
	 *
	 * @static
	 * @returns true or false
	 * @memberof ModelBaseMongoose
	 */
	static getShouldLogDbActions() {
		return true;
	}
	//---------------------------------------------------------------------------





























	//---------------------------------------------------------------------------
	static extractMongooseDbSchemaDefintion() {
		// get the full schema definition
		const schemaDefinition = this.getSchemaDefinition();
		// now build a new object with only the key mongoose values
		const mongooseDbSchemaDefinition = {};
		for (const key in schemaDefinition) {
			if (schemaDefinition[key].mongoose) {
				mongooseDbSchemaDefinition[key] = schemaDefinition[key].mongoose;
			}
		}
		// return it
		return mongooseDbSchemaDefinition;
	}


	// User model mongoose db schema
	static buildMongooseDbSchema(mongooser) {
		const mongooseDbSchemaDefinition = this.extractMongooseDbSchemaDefintion();
		this.schema = new mongooser.Schema(mongooseDbSchemaDefinition, {
			collection: this.getCollectionName(),
		});
		return this.schema;
	}


	// subbclasses implement this
	static calcSchemaDefinition() {
		return {};
	}


	static getSchemaDefinition() {
		// this is the one that should be called
		// returns cached value
		if (!this.cachedSchemaDefinition) {
			this.cachedSchemaDefinition = this.calcSchemaDefinition();
		}
		return this.cachedSchemaDefinition;
	}
	//---------------------------------------------------------------------------


	//---------------------------------------------------------------------------
	static getBaseSchemaType(fieldname) {
		const baseSchemaDefinition = this.getBaseSchemaDefinition();
		if (baseSchemaDefinition[fieldname]) {
			return baseSchemaDefinition[fieldname].type;
		}
		return null;
	}


	// ATTN: TODO -- cache the schema definition and extras
	static getSchemaFieldVal(fieldName, key, defaultVal) {
		const modelSchemaDefinition = this.getSchemaDefinition();
		if (modelSchemaDefinition[fieldName] &amp;&amp; modelSchemaDefinition[fieldName][key] !== undefined) {
			return modelSchemaDefinition[fieldName][key];
		}
		return defaultVal;
	}

	static async calcHiddenSchemaKeysForView(jrContext, viewType) {
		const retKeys = [];
		const modelSchemaDefinition = this.getSchemaDefinition();
		const keys = Object.keys(modelSchemaDefinition);
		let keyHideArray;
		let visibleFunction, isVisible;

		await jrhMisc.asyncAwaitForEachFunctionCall(keys, async (fieldName) => {
			keyHideArray = modelSchemaDefinition[fieldName].hide;
			if ((keyHideArray === true) || (jrhMisc.isInAnyArray(viewType, keyHideArray))) {
				retKeys.push(fieldName);
			} else {
				visibleFunction = modelSchemaDefinition[fieldName].visibleFunction;
				if (visibleFunction) {
					isVisible = await visibleFunction(jrContext, viewType, fieldName, null, null, null);
					if (!isVisible) {
						retKeys.push(fieldName);
					}
				}
			}
		});

		return retKeys;
	}
	//---------------------------------------------------------------------------




























	//---------------------------------------------------------------------------
	static setCrudBaseUrl(urlPath) {
		this.crudBaseUrl = urlPath;
	}

	static getCrudUrlBase(suburl, id) {
		// return url for crud access, adding suburl and id

		if (id &amp;&amp; !jrhMongo.isValidMongooseObjectId(id)) {
			// invalid id
			return "";
		}

		let url = this.crudBaseUrl;
		if (suburl) {
			url += "/" + suburl;
		}
		if (id) {
			url += "/" + id.toString();
		}
		return url;
	}
	//---------------------------------------------------------------------------





	//---------------------------------------------------------------------------
	getExtraDataField(key, defaultValue) {
		if (this.extraData === undefined || this.extraData[key] === undefined) {
			return defaultValue;
		}
		return this.extraData[key];
	}
	//---------------------------------------------------------------------------







	//---------------------------------------------------------------------------
	// create new obj
	static createModel(inobj) {
		const obj = {
			version: this.getVersion(),
			creator: null,
			creationDate: new Date(),
			modificationDate: null,
			disabled: 0,
			notes: "",
			...inobj,
		};
		const model = this.newMongooseModel(obj);
		return model;
	}

	// cacheable list of schema keys
	// ATTN: TODO - this is messy and confusing, fix it
	getModelObjPropertyList() {
		// cached value
		if (this.getModelClass().modelObjPropertyList) {
			return this.getModelClass().modelObjPropertyList;
		}
		const propkeys = Object.keys(this.getModelClass().getSchemaDefinition());
		return propkeys;
	}
	//---------------------------------------------------------------------------




	//---------------------------------------------------------------------------
	static async setupModelSchema(mongooser) {

		// we only do this IF it"s not yet been done
		if (this.modelSchema) {
			jrdebug.cdebug("misc", "Skipping model rebuild for " + this.getCollectionName());
			return;
		}

		// jrdebug.debug("Setting up model schema for " + this.getCollectionName());

		// compile the model scheme
		this.modelSchema = this.buildMongooseDbSchema(mongooser);

		// this is an attempt to cache this information but it doesn't seem to work
		this.modelObjPropertyList = Object.keys(this.getSchemaDefinition());

		// 5/8/19 trying to tie our model class to the mongoose model
		// see https://mongoosejs.com/docs/advanced_schemas.html
		// this idea is that this transfers the functions and properties from the model class to the schema
		// This lets us do things like load a user document, and then call methods on the document returned (see user password checking)
		// We can pass lean option in queries to bypass this on a case-by-case-basis
		await this.modelSchema.loadClass(this);

		// create the mongoose model
		const collectionName = this.getCollectionName();
		this.setMongooseModel(await mongooser.model(collectionName, this.modelSchema));


		// ensure the collection is created now even though it's blank
		// ATTN: 5/11/19 - mongoose/mongodb is having a weird fit here, where it is throwing an error
		//  about connection already exists if while making schema it is creating indexes, even if strict = false
		// so we are going to try to check for collection manually before creating it.
		// note that even with this check, we must use the default strict:false, otherwise we still get a complaint
		if (!await this.collectionExists(mongooser, collectionName)) {
			await this.getMongooseModel().createCollection({ strict: false });
		}

		// any database initialization to be done (e.g. create initial objects/documents, etc.)
		await this.dbInit();
	}


	static async collectionExists(mongooser, collectionName) {
		// return true if collection already exists
		const list = await mongooser.connection.db.listCollections({ name: collectionName }).toArray();
		if (list.length > 0) {
			return true;
		}
		// not found
		return false;
	}


	static async dbInit() {
		// nothing to do in base class
	}


	async dbSave(jrContext) {
		// simple wrapper (for now) around mongoose model save
		// NOTE: this should always be used instead of superclass built-in mongoose save() function
		// NOTE: if jrContext is specified then exceptions are not thrown and errors are added to it; otherwise exception is thrown
		// ATTN: TODO it might be better to use an explicit flag regarding whether to throw exceptions and always allow passing in of jrContext
		// ATTN: TODO log the errors here as db.severe if we have jrContext to do so?

		// update modification date
		this.updateModificationDate();

		// save and we catch any exceptions and convert to jrResults
		let retv;
		let serr;
		try {
			retv = await await this.save();
		} catch (err) {
			// just set serr and drop down
			serr = err;
		}

		if (serr !== undefined) {
			if (jrContext === undefined) {
				// just let exceptions percolate up
				console.log("ATTN: Unexpected error while trying to mongoose save object:");
				console.log(serr);
				throw serr;
			}
			// if jrContext *is* set, we add error to it and do NOT throw exception
			jrContext.pushError("Failed to save " + this.getModelClass().getNiceName() + ". " + serr.toString());
			return null;
		}
		// success
		// we don't push a success result here because we would see it in operations we dont want messages on
		// jrContext.pushSuccess(this.getModelClass().getNiceName() + " saved on " + jrhMisc.getNiceNowString() + ".");
		return retv;
	}
	//---------------------------------------------------------------------------





	/**
	 * A wrapper around doValidateAndSave that can set ownership of the object when appropriate
	 *
	 * @static
	 * @param {*} jrResult
	 * @param {*} options
	 * @param {*} flagSave
	 * @param {*} user
	 * @param {*} source
	 * @param {*} saveFields
	 * @param {*} preValidatedFields
	 * @param {*} ignoreFields
	 * @param {*} obj
	 * @param {*} flagUpdateUserRolesForNewObject
	 * @memberof ModelBaseMongoose
	 */
	static async validateSave(jrContext, options, flagSave, user, source, saveFields, preValidatedFields, ignoreFields, obj, flagUpdateUserRolesForNewObject) {
		// is this a new object?
		const flagIsNew = obj.isNew;
		// call validate and save
		const savedObj = await this.doValidateAndSave(jrContext, options, flagSave, user, source, saveFields, preValidatedFields, ignoreFields, obj);
		// success?
		if (flagUpdateUserRolesForNewObject &amp;&amp; flagIsNew &amp;&amp; !jrContext.isError() &amp;&amp; user) {
			// successful save and it was a new object, and caller wants us to set roles of owner
			await user.addOwnerCreatorRolesForNewObject(jrContext, obj);
			if (jrContext.isError()) {
				// error setting roles, which means we would like to DESTROY the object and reset it..
				// ATTN: unfinished
				const emsg = "ATTN: Failed to set ownership roles on " + obj.getLogIdString();
				arserver.logr(jrContext, "error.imp", emsg);
				jrdebug.debug(emsg);
			}
		}
		return savedObj;
	}


	static async validateAndSaveNewWrapper(jrContext, options, flagSave, user, source, saveFields, preValidatedFields, ignoreFields, flagUpdateUserRolesForNewObject) {
		const newObj = this.createModel({});
		await this.validateSave(jrContext, options, flagSave, user, source, saveFields, preValidatedFields, ignoreFields, newObj, flagUpdateUserRolesForNewObject);
		return newObj;
	}
	//---------------------------------------------------------------------------




	//---------------------------------------------------------------------------
	// subclasses implement this
	static async doValidateAndSave(jrContext, options, flagSave, user, source, saveFields, preValidatedFields, ignoreFields, obj) {
		jrContext.pushError("Internal error: No subclassed procedure to handle doValidateAndSave() for " + this.getCollectionName() + " model");
		return null;
	}

	static async validateAndSaveNew(jrContext, options, flagSave, user, source, saveFields, preValidatedFields, ignoreFields) {
		const newObj = this.createModel({});
		await this.doValidateAndSave(jrContext, options, flagSave, user, source, saveFields, preValidatedFields, ignoreFields, newObj);
		return newObj;
	}
	//---------------------------------------------------------------------------


	//---------------------------------------------------------------------------
	static getSaveFields(operationType) {
		// operationType is commonly "crudAdd", "crudEdit"
		// return an array of field names that the user can modify when saving an object
		// this is a safety check to allow us to handle form data submitted flexibly and still keep tight control over what data submitted is used
		// subclasses implement; by default we return empty array
		// NOTE: this list can be generated dynamically based on logged in user
		return [];
	}


	// ATTN: this function typically does not have to run async so its cpu inefficient to make it async but rather than have 2 copies of this function to maintain, we use just async one
	// ATTN: TODO in future make a version of this that is sync; or find some better way to handle it
	static async validateMergeAsync(jrContext, fieldNameSource, fieldNameTarget, source, saveFields, preValidatedFields, obj, flagRequired, validateFunction) {
		//
		// source and target field names might be different (for example, password is plaintext hashed into a different target fieldname)
		if (fieldNameTarget === "") {
			fieldNameTarget = fieldNameSource;
		}

		// first see if value was pre-validated
		let validatedVal, unvalidatedVal;
		let fieldNameUsed;
		if (preValidatedFields &amp;&amp; (preValidatedFields === "*" || (preValidatedFields.includes(fieldNameTarget)))) {
			// field is pre-validated, so just grab its prevalidated value
			fieldNameUsed = fieldNameTarget;
			unvalidatedVal = source[fieldNameSource];
			validatedVal = source[fieldNameTarget];
		} else {
			fieldNameUsed = fieldNameSource;
			unvalidatedVal = source[fieldNameSource];
		}


		// if value isnt set, but a fieldname_checkbox value is, then we know this is a case of html form processing not parsing the checkbox unchecked
		if (validatedVal === undefined &amp;&amp; unvalidatedVal === undefined) {
			// no value found
			if (source[fieldNameSource + "_checkbox"]) {
				// found checkbox, so unvalidated value should be considered set to false
				unvalidatedVal = false;
			}
		}


		// check if the value is even set (!== undefined).  this is either an error, or a case where we return doing nothing
		if (validatedVal === undefined &amp;&amp; unvalidatedVal === undefined) {
			// no value found
			// throw error if required and it's not ALREADY in the object we are merging into
			if (flagRequired &amp;&amp; obj[fieldNameTarget] === undefined) {
				// it's an error that its not provided and not set in obj already
				// ATTN: note that this test does *NOT* require that the field be set in source, just that it already be set in obj if not
				jrContext.pushError("Required value not provided for: " + fieldNameSource);
			}
			// ATTN: do not let validator have a chance to run??
			return undefined;
		}

		// ok its set. if we aren't allowed to save this field, its an error
		if (saveFields !== "*" &amp;&amp; !(saveFields.includes(fieldNameUsed))) {
			jrContext.pushError("Permission denied to save value for: " + fieldNameUsed);
			return undefined;
		}

		// now resolve it if its not yet resolved
		if (validatedVal === undefined) {
			validatedVal = await validateFunction(jrContext.result, fieldNameSource, unvalidatedVal, flagRequired);
			// if its an error, for example during validation, we are done
			if (jrContext.isError()) {
				return undefined;
			}
		}

		// secondary check for missing value, after we run the valueFunction function
		if (validatedVal === undefined) {
			// if undefined is returned, we do NOT save the value
			if (flagRequired &amp;&amp; obj[fieldNameTarget] === undefined) {
				// it's an error that its not provided and not set in obj already
				// ATTN: note that this test does *NOT* require that the field be set in source, just that it already be set in obj if not
				jrContext.pushError("Required value not provided for: " + fieldNameUsed);
			}
			// should we return undefined, OR should we return obj[fieldNameTarget] if its already in there
			return undefined;
		}

		// null value will also cause error if we're not allowed to be blank
		if (flagRequired &amp;&amp; validatedVal === null) {
			// error if they are trying to save a NULL value and we've been told that the field is required
			// above we check for undefined, which means DONT CHANGE the value; null means CHANGE The value to null
			jrContext.pushError("Required value not provided for: " + fieldNameUsed);
		}

		// success, set it
		obj[fieldNameTarget] = validatedVal;
		// tell object we have set it
		obj.notifyValueModified(fieldNameTarget, validatedVal);
		return validatedVal;
	}
	//---------------------------------------------------------------------------



	//---------------------------------------------------------------------------
	notifyValueModified(key, val) {
		// ATTN: 4/18/20 -- despite documentation, this doesnt ACTUALLY seem to be needed even for mixed schematype..
		if (false) {
			// some mongoose models need this to be called, like those with Mixed schema, like extraData
			// doesn't seem to be any harm in calling for all vars
			// this.markModified(key);
		}
	}
	//---------------------------------------------------------------------------




	//---------------------------------------------------------------------------
	/**
	 * Complain about fields we found that we are refusing to save
	 *
	 * @static
	 * @param {*} jrResult
	 * @param {*} options
	 * @param {*} source
	 * @param {*} saveFields
	 * @param {*} preValidatedFields
	 * @memberof ModelBaseMongoose
	 */
	static async validateComplainExtraFields(jrContext, options, source, saveFields, preValidatedFields, ignoreFields) {
		// walk the properties in source, and complain if not found in saveFields, preValidatedFields, and ignoreFields
		for (const prop in source) {
			if (Object.prototype.hasOwnProperty.call(source, prop)) {
				if ((saveFields &amp;&amp; saveFields.includes(prop)) || (preValidatedFields &amp;&amp; preValidatedFields.includes(prop)) || (ignoreFields &amp;&amp; ignoreFields.includes(prop))) {
					// good
					continue;
				} else {
					// not found, first check if its a _checkbox version of an allowed field
					if (prop.endsWith("_checkbox")) {
						const preprop = prop.substr(0, prop.length - 9);
						if ((saveFields &amp;&amp; saveFields.includes(preprop)) || (preValidatedFields &amp;&amp; preValidatedFields.includes(preprop)) || (ignoreFields &amp;&amp; ignoreFields.includes(preprop))) {
							// good
							continue;
						}
					}
					// error
					jrContext.pushFieldError(prop, "Not allowed to save this field (" + prop + ").");
				}
			}
		}
	}
	//---------------------------------------------------------------------------




	//---------------------------------------------------------------------------
	static async validateAddEditFormId(jrContext, formTypeStr) {
		// push error into jrResult on error
		// return {id, existingModel}

		// get id from form
		const id = jrContext.req.body._editId;

		// add form should not have shortcode specified
		if (formTypeStr === "add") {
			// id should be blank in this case
			if (id) {
				jrContext.pushError("Unexpected Id specified in " + this.getNiceName() + " ADD submission.");
				return {};
			}
			// fine
			return {
				id: null,
				existingModel: null,
			};
		}

		// non-add form MUST have shortcode specified
		if (!id) {
			jrContext.pushError("Id for " + this.getNiceName() + " missing from NON-ADD submission.");
			return {};
		}

		// now try to look it up
		const existingModel = await this.mFindOneById(id);
		if (!existingModel) {
			jrContext.pushError("Lookup of " + this.getNiceName() + " not found for id specified.");
			return {};
		}

		// success
		return {
			id,
			existingModel,
		};
	}


	static async validateAddEditFormIdMakeObj(jrContext, formTypeStr) {
		// return an object with validated properties
		// OR an instance of jrResult if error

		// get any existing model
		const { id, existingModel } = await this.validateAddEditFormId(jrContext, formTypeStr);
		if (jrContext.isError()) {
			return null;
		}

		if (!existingModel) {
			// create new one (doesn't save it yet)
			return this.createModel();
		}

		return existingModel;
	}
	//---------------------------------------------------------------------------



	//---------------------------------------------------------------------------
	// validate.  push error to jrResult on error, return good value on success

	static async validateModelFieldUnique(jrContext, key, val, existingModel) {
		if (!val) {
			jrContext.pushFieldError(key, "Value for " + key + " cannot be blank (must be unique).");
		}
		// must be unique so we search for collissions
		let criteria;
		if (existingModel._id) {
			// there is an id for the object we are working on, so DONT include that one when searching for a colission
			criteria = {
				[key]: val,
				_id: { $ne: existingModel._id },
			};
		} else {
			criteria = {
				[key]: val,
			};
		}

		const clashObj = await this.mFindOne(criteria);
		if (clashObj) {
			// error
			jrContext.pushFieldError(key, "Duplicate " + key + " entry found for another " + this.getNiceName());
			// doesnt matter what we return?
			return null;
		}

		return val;
	}
	//---------------------------------------------------------------------------






	//---------------------------------------------------------------------------
	static validateShortcodeSyntax(jrContext, key, val) {
		if (!val) {
			if (jrContext) {
				const sstr = (key === "shortcode") ? "shortcode" : "shortcode (" + key + ")";
				jrContext.pushFieldError(key, sstr + " cannot be left blank");
			}
			return null;
		}

		// uppercase it
		val = val.toUpperCase();

		// simple regex test it should only contain letters and numbers and a few basic syboles
		const regexPat = /^[A-Z0-9_\-.]*$/;
		if (!regexPat.test(val)) {
			if (jrContext) {
				const sstr2 = (key === "shortcode") ? "shortcode" : "shortcode (" + key + ")";
				jrContext.pushFieldError(key, "Syntax error in " + sstr2 + " value; it should be uppercase, and shouold contain only the characters A-Z 0-9 _-. (no spaces).");
			}
			return null;
		}

		return val;
	}


	static async validateShortcodeUnique(jrContext, key, val, existingModel) {

		// first basic validation (and fixing) of shortcode syntax
		val = this.validateShortcodeSyntax(jrContext, key, val);
		if (!val) {
			return val;
		}

		// must be unique so we search for collissions
		let criteria;
		if (existingModel._id) {
			// there is an id for the object we are working on, so DONT include that one when searching for a colission
			criteria = {
				[key]: val,
				_id: { $ne: existingModel._id },
			};
		} else {
			criteria = {
				[key]: val,
			};
		}

		if (await this.isShortcodeInUse(criteria)) {
			jrContext.pushFieldError(key, "Duplicate " + key + " entry found for another " + this.getNiceName());
			// doesnt matter what we return?
			return null;
		}

		return val;
	}


	static async isShortcodeInUse(criteria) {
		const clashObj = await this.mFindOne(criteria);
		if (clashObj) {
			return true;
		}
		return false;
	}


	static async makeRandomShortcode(key) {
		// try to make an unused random shortcode
		const maxTrycount = 100;
		const shortcodeLen = 9;
		let shortcode;
		const criteria = {};
		const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

		for (let trycount = 0; trycount &lt; maxTrycount; trycount += 1) {
			// random shortcode
			shortcode = "RND" + jrhCrypto.genRandomStringFromCharSet(charset, shortcodeLen);
			criteria[key] = shortcode;
			// see if it's in use
			if (!(await this.isShortcodeInUse(criteria))) {
				// found one not in use
				return shortcode;
			}
		}
		// not found
		return null;
	}
	//---------------------------------------------------------------------------










	//---------------------------------------------------------------------------
	static validateModelFielDisbled(jrContext, key, val, flagRequired) {
		// the disabled field for resource models must be a postitive integer (0 meaning not disabled, higher than 0 various flavors of being a disabled resource)
		return jrhValidate.validateIntegerRange(jrContext, key, val, 0, 999999, flagRequired);
	}

	static validateModelFieldId(jrContext, val) {
		if (!jrhMongo.isValidMongooseObjectId(val)) {
			jrContext.pushError("No valid id specified.");
			return null;
		}
		return val;
	}

	static async validateModelFieldAppId(jrContext, key, val, user) {
		const AppModel = jrequire("models/app");
		const appIds = await AppModel.buildSimpleAppIdListUserTargetable(user);
		if (val === "") {
			jrContext.pushFieldError(key, "app id may not be blank.");
			return null;
		}
		if (!appIds || appIds.indexOf(val) === -1) {
			jrContext.pushFieldError(key, "specified app id is inaccessible.");
			console.log("ATTN:DEBUG APPIDS");
			console.log(appIds);
			return null;
		}
		// valid
		return val;
	}

	static async validateModelFieldRoomId(jrContext, key, val, user) {
		const RoomModel = jrequire("models/room");
		const roomIds = await RoomModel.buildSimpleRoomIdListUserTargetable(user);
		if (val === "") {
			jrContext.pushFieldError(key, "room id may not be blank.");
			return null;
		}
		if (!roomIds || roomIds.indexOf(val) === -1) {
			jrContext.pushFieldError(key, "specified room id is inaccessible.");
			return null;
		}
		// valid
		return val;
	}
	//---------------------------------------------------------------------------









	//---------------------------------------------------------------------------
	// accessors
	getIdAsM() {
		return this._id;
	}

	getIdAsString() {
		if (true) {
			// ATTN: does this work?
			return this.id;
		}
		// old
		if (!this._id) {
			return "";
		}
		return this._id.toString();
	}

	getLogIdString() {
		// human readable id string for use in log messages that we could parse to get a link
		// ATTN: note we use the "this.constructor.staticfunc" syntax to access static class function from member
		// return this.getModelClass().getLoggingString() + "#" + this.getIdAsString();
		return this.getModelClass().getLogStringFromId(this.getIdAsString());
	}

	static getLogStringFromId(id) {
		return this.getLoggingString() + "#" + id;
	}



	isRealObjectInDatabase() {
		return !this.getIsNew();
	}

	getIsNew() {
		// return TRUE if it is new and not yet saved
		return this.isNew;
	}

	getCreationDate() {
		return this.creationDate;
	}
	//---------------------------------------------------------------------------


	//---------------------------------------------------------------------------
	updateModificationDate() {
		this.modificationDate = new Date();
	}
	//---------------------------------------------------------------------------













































	//---------------------------------------------------------------------------
	// isolate use of this.mongooseModel
	static getMongooseModel() {
		return this.mongooseModel;
	}

	static setMongooseModel(val) {
		this.mongooseModel = val;
	}

	static newMongooseModel(obj) {
		const retv = new this.mongooseModel(obj);
		return retv;
	}
	//---------------------------------------------------------------------------




















	//---------------------------------------------------------------------------
	// rather than letting different models call mongoose directly, we try to put a thin wrapper of our own


	static async mFindOne(...args) {
		// actually call mongooseModel mFindOne
		const retv = await this.mongooseModel.findOne(...args).exec();
		return retv;
	}


	static async mFindOneAndUpdate(criteria, setObject) {
		const retv = await this.mongooseModel.findOneAndUpdate(criteria, setObject).exec();
		return retv;
	}


	static async mFindAll(criteria) {
		const retv = await this.mongooseModel.find(criteria).exec();
		return retv;
	}


	static async mFindAllAndSelect(criteria, projection) {
		// pass null as criteria to get full set
		// ATTN: we dont exec when we select?
		const retv = await this.mongooseModel.find(criteria).select(projection);
		return retv;
	}


	static async mFindMongoose(...args) {
		// just pass through to mongoose find
		const retv = await this.mongooseModel.find(...args).exec();
		return retv;
	}
	//---------------------------------------------------------------------------





	//---------------------------------------------------------------------------
	// more elaborate helpers

	/**
	 * Find some items (possibly paginated)
	 * This is used in our crud system
	 *
	 * @static
	 * @param {object} query
	 * @param {object} queryOptions
	 * @param {object} jrResult
	 * @returns a tuble [items, fullQueryResultCount] - where fullQueryResultCount may be larger than items.length if pagination is only bringing us some of the reulst
	 * @memberof ModelBaseMongoose
	 */

	static async mFindAllByQuery(jrContext, query, queryOptions, flagDoLeanRequestNotFullClasses) {
		// fetch the array of items to be displayed in grid
		// see https://thecodebarbarian.com/how-find-works-in-mongoose

		// ATTN: IMPORTANT -- when this is set, we don't instantiate full model classes when retrieving
		// we force caller to specify this explicitly instead of embedding it in queryOptions so that it sticks out more like a sore thumb since it can have important ramifications
		if (flagDoLeanRequestNotFullClasses) {
			queryOptions.lean = true;
		}

		const queryProjection = null;
		try {
			const items = await this.mongooseModel.find(query, queryProjection, queryOptions).exec();

			let resultCount;
			const isQueryEmpty = ((Object.keys(query)).length === 0);
			if (isQueryEmpty) {
				resultCount = await this.mongooseModel.countDocuments();
			} else {
				resultCount = await this.mongooseModel.countDocuments(query).exec();
			}

			return [items, resultCount];
		} catch (err) {
			jrContext.pushError("Error executing find filter: " + JSON.stringify(query, null, " ") + ":" + err.message);
			return [[], 0];
		}
	}
	//---------------------------------------------------------------------------




	//---------------------------------------------------------------------------
	static async mFindAndDeleteMany(criteria) {
		await this.getMongooseModel().deleteMany(criteria).exec();
	}
	//---------------------------------------------------------------------------


























	//---------------------------------------------------------------------------
	// shortcuts that call above

	static async mFindOneByShortcode(shortcodeval) {
		// return null if not found
		if (!shortcodeval) {
			return null;
		}
		return await this.mFindOne({ shortcode: shortcodeval });
	}


	// lookup user by their id
	static async mFindOneById(id) {
		// return null if not found
		if (!id) {
			return null;
		}
		return await this.mFindOne({ _id: id });
	}


	static async mFindOneByKeyValue(key, val) {
		return await this.mFindOne({ [key]: val });
	}
	//---------------------------------------------------------------------------






























	//---------------------------------------------------------------------------
	modelObjPropertyCopy(flagIncludeId) {
		// copy the properties in schema
		const obj = {};
		const keylist = this.getModelObjPropertyList();

		keylist.forEach((key) => {
			if (key in this) {
				obj[key] = this[key];
			}
		});

		if (flagIncludeId) {
			obj._id = this._id;
		}

		return obj;
	}
	//---------------------------------------------------------------------------





























































	//---------------------------------------------------------------------------
	// subclasses can subclass this for crud add/edit
	static async calcCrudEditHelperData(jrContext, id) {
		return undefined;
	}


	// subclasses can subclass this for crud view
	static async calcCrudViewHelperData(jrContext, id, obj) {
		return undefined;
	}


	// subclasses can subclass this list grid helper
	static async calcCrudListHelperData(jrContext, user, baseUrl, protectedFields, hiddenFields) {
		// perform a find filter and create table grid

		// schema for obj
		const gridSchema = this.getSchemaDefinition();

		// force add the invisible id field to schema for display
		// we shouldn't have to do this anymore, we found out had to add it to the model schema
		if (false) {
			gridSchema._id = { type: "id" };
		}

		// headers for list grid
		const gridHeaders = [];

		// default sorting?
		const crudDefaults = this.getCrudDefaults();

		// options for filter construction
		const filterOptions = {
			defaultPageSize: 10,
			minPageSize: 1,
			maxPageSize: 1000,
			defaultSortField: jrhMisc.getNonNullValueOrDefault(crudDefaults.sortField, "_id"),
			defaultSortDir: jrhMisc.getNonNullValueOrDefault(crudDefaults.sortDir, "desc"),
			alwaysFilter: [],
			protectedFields,
			hiddenFields,
		};

		// convert filter into query and options
		const jrhMongoFilter = require("../helpers/jrh_mongo_filter");
		const { query, queryOptions, queryUrlData } = jrhMongoFilter.buildMongooseQueryFromReq(jrContext, filterOptions, gridSchema);



		// ATTN: IMPORTANT! 5/20/20
		// Force the lean option to speed up retrieving of results, since we only need for read-only display here; see https://mongoosejs.com/docs/tutorials/lean.html
		// Note that if we wanted to call methods on the model class we couldn't do this, as it returns results as plain generic objects
		const flagDoLeanRequestNotFullClasses = false;




		// add filter to not show vdeletes if appropriate
		await this.addUserDisabledVisibilityToQuery(jrContext, user, query);



		// get the items using query
		const [gridItems, resultcount] = await this.mFindAllByQuery(jrContext, query, queryOptions, flagDoLeanRequestNotFullClasses);
		queryUrlData.resultCount = resultcount;

		// store other stuff in queryUrl data to aid in making urls for pager and grid links, etc.
		queryUrlData.baseUrl = baseUrl;
		queryUrlData.tableId = this.getCollectionName();

		// return constructed object -- this is listHelperData in template
		return {
			modelClass: this,
			gridSchema,
			gridHeaders,
			query,
			queryOptions,
			queryUrlData,
			gridItems,
			filterOptions,
		};
	}



	static async calcCrudStatsHelperData(jrContext) {
		return undefined;
	}
	//---------------------------------------------------------------------------






	//---------------------------------------------------------------------------
	/**
	 * This adds to a query a filter that makes virtually deleted objects inaccessible if the user doesn't have permission.
	 * Modifies the passed query.
	 *
	 * @static
	 * @param {object} user
	 * @param {object} query
	 * @memberof ModelBaseMongoose
	 */
	static async addUserDisabledVisibilityToQuery(jrContext, user, query) {

		if (await user.aclHasPermissionSeeVDeletes(jrContext, this)) {
			// they are allowed to see the virtually deleted, so just return
			return;
		}

		// we need to filter out virtual deletes
		const addFilter = {
			$ne: 2,
		};
		if (!query.disabled) {
			// just add the filter
			query.disabled = addFilter;
		} else {
			// more complicated, we have to inject it
			const oldDisabled = query.disabled;
			delete query.disabled;
			if (query.$and) {
				// there is an and we need to add it to
				query.$and.push(oldDisabled);
				query.$and.push(addFilter);
			} else {
				// there is no and, so create one
				query.$and = [
					{ disabled: oldDisabled },
					{ disabled: addFilter },
				];
			}
		}
	}
	//---------------------------------------------------------------------------




	//---------------------------------------------------------------------------
	static async validateGetObjByIdDoAclRenderErrorPageOrRedirect(jrContext, user, val, aclTestName) {
		// get a model object, performing acl access check first
		// if not, render an error and return null

		let obj;
		const id = this.validateModelFieldId(jrContext, val);

		if (!jrContext.isError()) {
			// acl test
			if (!await arserver.aclRequireModelAccessRenderErrorPageOrRedirect(jrContext, user, this, aclTestName, id)) {
				// ATTN: note that in thie case, callee will have ALREADY rendered an error to the user about permissions, which is why we need to not drop down and re-render acl access error
				// but we DO need to push an error onto jrresult for our return check; note that text of error message is irrelevant
				jrContext.pushError("model access denied");
				return null;
			}
			// permission was granted
			// get object being edited
			obj = await this.mFindOneById(id);
			if (!obj) {
				jrContext.pushError("Could not find " + this.getNiceName() + " with that Id.");
			}
		}
		//
		if (jrContext.isError()) {
			// render error
			arserver.renderAclAccessErrorResult(jrContext, this);
			return null;
		}
		return obj;
	}
	//---------------------------------------------------------------------------



	//---------------------------------------------------------------------------
	static async validateMergeAsyncBaseFields(jrContext, options, flagSave, source, saveFields, preValidatedFields, obj) {
		// base fields shared among most models
		await this.validateMergeAsync(jrContext, "disabled", "", source, saveFields, preValidatedFields, obj, true, (jrr, keyname, inVal, flagRequired) => this.validateModelFielDisbled(jrr, keyname, inVal, flagRequired));
		await this.validateMergeAsync(jrContext, "notes", "", source, saveFields, preValidatedFields, obj, false, (jrr, keyname, inVal, flagRequired) => jrhValidate.validateString(jrr, keyname, inVal, flagRequired));
		// extraData json
		await this.validateMergeAsync(jrContext, "extraData", "", source, saveFields, preValidatedFields, obj, false, (jrr, keyname, inVal, flagRequired) => jrhValidate.validateJsonObjOrStringToObj(jrr, keyname, inVal, flagRequired));
	}
	//---------------------------------------------------------------------------







	//---------------------------------------------------------------------------
	// value function helpers

	/**
	 * Helper function that makes a value function where only admin can see
	 *
	 * @static
	 * @param {*} flagRequired
	 * @returns async value function
	 * @memberof ModelBaseMongoose
	 */
	static makeModelValueFunctionPasswordAdminEyesOnly(flagRequired) {
		// a value function usable by model definitions
		return async (jrContext, viewType, fieldName, obj, editData, helperData) => {
			let retv;
			const flagExistingIsNonBlank = (obj &amp;&amp; (obj.passwordHashed !== undefined &amp;&amp; obj.passwordHashed !== null &amp;&amp; obj.password !== ""));

			if (editData &amp;&amp; fieldName in editData) {
				// they are editing this field on a crud form, return the current editing value (not any previous val of object)
				retv = jrhText.jrHtmlFormInputPassword("password", editData, flagRequired, flagExistingIsNonBlank);
				return retv;
			}

			const isLoggedInUserSiteAdmin = await arserver.isLoggedInUserSiteAdmin(jrContext);
			if (viewType === "view" &amp;&amp; obj) {
				if (isLoggedInUserSiteAdmin) {
					// for debuging
					retv = obj.passwordHashed;
				} else {
					// safe
					retv = this.safeDisplayPasswordInfoFromPasswordHashed(obj.passwordHashed);
				}
			} else if (viewType === "add" || viewType === "edit") {
				retv = jrhText.jrHtmlFormInputPassword("password", obj, flagRequired, flagExistingIsNonBlank);
			} else if (viewType === "list" &amp;&amp; obj) {
				if (isLoggedInUserSiteAdmin) {
					retv = obj.passwordHashed;
				} else if (!obj.passwordHashed) {
					retv = "";
				} else {
					retv = "[HIDDEN]";
				}
			}
			//
			if (retv === undefined) {
				return "";
			}
			return retv;
		};
	}


	/**
	 * Helper function to make a value function for the extraData field
	 *
	 * @static
	 * @returns async value function
	 * @memberof ModelBaseMongoose
	 */
	static makeModelValueFunctionExtraData() {
		// a value function usable by model definitions
		return async (jrContext, viewType, fieldName, obj, editData, helperData) => {
			let str;

			if (editData &amp;&amp; fieldName in editData) {
				// they are editing this field on a crud form, return the current editing value (not any previous val of object)
				str = editData[fieldName];
			} else if (obj &amp;&amp; obj.extraData) {
				if (typeof obj.extraData === "string") {
					// already a string -- this is used when form error being reshown..
					str = obj.extraData;
				} else {
					str = JSON.stringify(obj.extraData, null, " ");
				}
			} else {
				// str will be undefined, which is handled in sanitizeUnsafeText
			}

			// let them edit the json string
			if (viewType === "add" || viewType === "edit") {
				// sanitize html
				str = jrhText.sanitizeUnsafeText(str, false, false);
				// wrap in input textarea
				str = `&lt;textarea name="${fieldName}" rows="4" cols="80">${str}&lt;/textarea>`;
			} else {
				// just for display sanitize html
				str = jrhText.sanitizeUnsafeText(str, true, true);
			}

			// return it
			return str;
		};
	}



	/**
	 * Helper function to make a value function for an object's id crud field
	 *
	 * @static
	 * @param {*} modelClass
	 * @param {*} fieldId
	 * @param {*} fieldLabel
	 * @param {*} fieldList
	 * @returns an async value function
	 * @memberof ModelBaseMongoose
	 */
	static makeModelValueFunctionObjectId(modelClass) {
		return async (jrContext, viewType, fieldName, obj, editData, helperData) => {
			if (editData &amp;&amp; fieldName in editData) {
				// no way to edit this
			}

			if (obj) {
				const objid = obj[fieldName];
				if (objid) {
					// jrdebug.debugObj(obj, "Obj test");
					const alink = modelClass.getCrudUrlBase("view", objid);
					return `&lt;a href="${alink}">${objid}&lt;/a>`;
				}
			}
			return "";
		};
	}


	/**
	 * Helper function to make a value function for an object's id crud field, where there are a list of choices from helperdata
	 *
	 * @static
	 * @param {*} modelClass
	 * @param {*} fieldId
	 * @param {*} fieldLabel
	 * @param {*} fieldList
	 * @returns an async value function
	 * @memberof ModelBaseMongoose
	 */
	static makeModelValueFunctionCrudObjectIdFromList(modelClass, fieldId, fieldLabel, fieldList) {
		return async (jrContext, viewType, fieldName, obj, editData, helperData) => {
			let viewUrl, oLabel, rethtml, oid;

			if (editData &amp;&amp; editData[fieldId]) {
				// they are editing this field on a crud form, return the current editing value (not any previous val of object)
				oid = editData[fieldId];
				rethtml = jrhText.jrHtmlFormOptionListSelect(fieldId, helperData[fieldList], oid, true);
				return rethtml;
			}

			if (viewType === "view" &amp;&amp; obj) {
				viewUrl = modelClass.getCrudUrlBase("view", obj[fieldId]);
				oLabel = helperData[fieldLabel];
				rethtml = `${oLabel} (&lt;a href="${viewUrl}">#${obj[fieldId]}&lt;/a>)`;
				return rethtml;
			}
			if (viewType === "add" || viewType === "edit") {
				oid = obj ? obj[fieldId] : null;
				rethtml = jrhText.jrHtmlFormOptionListSelect(fieldId, helperData[fieldList], oid, true);
				return rethtml;
			}
			if (viewType === "list" &amp;&amp; obj) {
				viewUrl = modelClass.getCrudUrlBase("view", obj[fieldId]);
				rethtml = `&lt;a href="${viewUrl}">${obj[fieldId]}&lt;/a>`;
				return rethtml;
			}
			return undefined;
		};
	}
	//---------------------------------------------------------------------------



	//---------------------------------------------------------------------------
	/**
	 * Return a value function for showing the roles held by all users on a specific object
	 *
	 * @static
	 * @param {*} modelClass
	 * @returns async value function
	 * @memberof ModelBaseMongoose
	 */
	static makeModelValueFunctionRoleOnObjectList(modelClass) {
		const RoleModel = jrequire("models/role");
		return async (jrContext, viewType, fieldName, obj, editData, helperData) => {
			if (editData &amp;&amp; fieldName in editData) {
				// no way to edit this
			}

			// can't get roles?
			if (!obj || (!obj.getAllRolesOnThisObject &amp;&amp; !obj._id)) {
				return "n/a";
			}

			if (false &amp;&amp; viewType === "list") {
				// too heavy to retrieve in this mode
				return "...";
			}

			//
			if (obj.getAllRolesOnThisObject) {
				// it's a full object so we can resolve it
				// ATTN: 5/13/20 -- because this needs a valid object, it doesnt work in crud edit mode only crud view mode
				const roles = await obj.getAllRolesOnThisObject();
				return RoleModel.stringifyRoles(roles, true, false);
			}

			// a thin json object, but we still know how to do this
			if (obj._id) {
				const roles = await this.getAllRolesOnObjectById(obj._id);
				return RoleModel.stringifyRoles(roles, true, false);
			}

			// should never be able to get here
			return "n/a";
		};

	}
	//---------------------------------------------------------------------------







	//---------------------------------------------------------------------------
	static getNiceNamePluralized(num) {
		if (num === 1) {
			return num.toString() + " " + this.getNiceName();
		}
		return num.toString() + " " + this.getNiceName() + "s";
	}


	static getNiceNameWithId(id) {
		return this.getNiceName() + " #" + id;
	}
	//---------------------------------------------------------------------------































	//---------------------------------------------------------------------------
	/**
	 * Delete the object AND do any cleanup, like deleteing accessory objects, removing references, etc.
	 * Just hand off to static class method
	 *
	 * @param {string} mode
	 * @param {object} jrResult
	 */
	async doChangeMode(jrContext, mode) {
		// just hand off to static class version
		await this.getModelClass().doChangeModeById(jrContext, this.getIdAsM(), mode);
	}



	/**
	 * change mode (delete) the object AND do any cleanup, like deleteing accessory objects, removing references, etc.
	 *
	 * @static
	 * @param {string} id
	 * @param {string} mode
	 * @param {object} jrResult
	 */
	static async doChangeModeById(jrContext, id, mode) {

		if (mode === appdef.DefMdbRealDelete) {
			// direct database delete
			await this.getMongooseModel().deleteOne({ _id: id }, (err) => {
				if (err) {
					const msg = "Error while tryign to delete " + this.getNiceNameWithId(id) + ": " + err.message;
					jrContext.pushError(msg);
				} else {
					// log the action
					if (this.getShouldLogDbActions()) {
						arserver.logr(jrContext, "db.delete", "Deleted " + this.getNiceNameWithId(id));
					}
				}
			});
		} else {
			// change mode (enable, disable, vdelete, etc.)
			// just sets the field "disabled" to mode value
			// see https://mongoosejs.com/docs/documents.html#updating
			const nowDate = new Date();
			await this.getMongooseModel().updateOne({ _id: id }, { $set: { disabled: mode, modificationDate: nowDate } }, (err) => {
				if (err) {
					const msg = "Error while changing to " + appdef.DefStateModeLabels[mode] + "  " + this.getNiceNameWithId(id) + ": " + err.message;
					jrContext.pushError(msg);
				} else {
					if (this.getShouldLogDbActions()) {
						// log the action
						arserver.logr(jrContext, "db.modify", "Changing to " + appdef.DefStateModeLabels[mode] + "  " + this.getNiceNameWithId(id));
					}
				}
			});
		}

		if (jrContext.isError()) {
			return;
		}

		// success, now handle any post change operations (like deleting accessory objects, etc.)
		await this.auxChangeModeById(jrContext, id, mode);
	}




	static async doChangeModeByIdList(jrContext, idList, mode, flagSupressSuccessMessage) {
		// delete/disable a bunch of items
		let successCount = 0;

		// walk the list and do a deep delete of each
		let id;
		for (let i = 0; i &lt; idList.length; ++i) {
			id = idList[i];
			await this.doChangeModeById(jrContext, id, mode);
			if (jrContext.isError()) {
				break;
			}
			++successCount;
		}

		const modeLabel = jrhText.capitalizeFirstLetter(appdef.DefStateModeLabels[mode]);
		if (!jrContext.isError()) {
			if (!flagSupressSuccessMessage) {
				jrContext.pushSuccess(modeLabel + " " + this.getNiceNamePluralized(successCount) + ".");
			}
		} else {
			if (successCount > 0) {
				jrContext.pushError(modeLabel + " " + this.getNiceNamePluralized(successCount) + " before error occurred.");
			}
		}
	}



	// delete any ancillary deletions AFTER the normal delete
	// this would normally be subclassed by specific model
	static async auxChangeModeById(jrContext, id, mode) {
		// by default, nothing to do; subclasses can replace this

		// roles delete IF the object is really deleted (and the object was succesfully deletd)
		if (mode === appdef.DefMdbRealDelete) {
			await this.deleteAllRolesRelatedToObject(jrContext, id);
		}
	}
	//---------------------------------------------------------------------------




	//---------------------------------------------------------------------------
	async getAllRolesOnThisObject() {
		// get all roles held by all users on this object
		return await this.getModelClass().getAllRolesOnObjectById(this.getIdAsString());
	}


	static async getAllRolesOnObjectById(objectIdString) {
		const cond = {
			objectType: this.getAclName(),
			objectId: objectIdString,
		};
		const RoleModel = jrequire("models/role");
		const roles = await RoleModel.mFindRolesByCondition(cond);
		return roles;
	}


	static async deleteAllRolesRelatedToObject(jrContext, id) {
		const cond = {
			objectType: this.getAclName(),
			objectId: id,
		};
		const RoleModel = jrequire("models/role");
		// await RoleModel.deleteRolesByCondition(jrContext, cond);
		await RoleModel.mFindAndDeleteMany(cond);
		// log it
		await arserver.logr(jrContext, "acl.deleteRoles", "delete roles related to deleted object " + this.getLogStringFromId(id));
	}
	//---------------------------------------------------------------------------






	//---------------------------------------------------------------------------
	// ATTN: first stab at extracting a function to do what crudaid does
	static async renderFieldValueHtml(jrContext, obj, editData, fieldName, crudSubType, helperData) {
		let isReadOnly = false;
		let val, valHtml;

		// editing or read only?
		if (crudSubType === "view" || crudSubType === "list") {
			isReadOnly = true;
		} else {
			// might be editable
			const readOnlyList = this.getSchemaFieldVal(fieldName, "readOnly", undefined);
			isReadOnly = ((readOnlyList === true) || jrhMisc.isInAnyArray(crudSubType, readOnlyList));
		}

		// now compute value

		// is there a custom value function? if so use that to grab value
		const valueFunction = this.getSchemaFieldVal(fieldName, "valueFunction");
		if (valueFunction) {
			// ok we have a custom function to call to get html to show for value (only pass in potential editData if not readOnly)
			valHtml = await valueFunction(jrContext, crudSubType, fieldName, obj, isReadOnly ? null : editData, helperData);
		}

		// if we havent yet set a value using valueFunctions (or if that returns undefined) then use default value
		if (valHtml === undefined) {
			let choices;
			let extra;
			let url;

			const format = this.getSchemaFieldVal(fieldName, "format", undefined);
			// compact view mode?
			const isCompact = (crudSubType === "list");

			// get the raw value we are going to use
			if (isReadOnly) {
				// read only just use obj value (ignore editData)
				if (obj &amp;&amp; fieldName in obj) {
					val = obj[fieldName];
				}
			} else {
				// it's editable, check for value in reqbody
				if (editData &amp;&amp; fieldName in editData) {
					// value set in editData
					val = editData[fieldName];
				} else if (obj &amp;&amp; fieldName in obj) {
					// value not set in editData, fall back on obj value if available
					val = obj[fieldName];
				} else {
					// not found in obj or editData (perhaps new object so obj is null)
					val = this.getSchemaFieldVal(fieldName, "defaultValue", undefined);
				}
			}

			// we have the raw value, now we need to format it nicely depending on format, etc.

			// is it multiple choice type?
			if (!isReadOnly) {
				// try to get editing choices
				choices = this.getSchemaFieldVal(fieldName, "choicesEdit", null);
				// if not found, drop down and fall back on choices
			}
			if (!choices) {
				choices = this.getSchemaFieldVal(fieldName, "choices", null);
			}

			// how we format will depend on whether its read only or editable input
			if (isReadOnly) {
				// read only value
				if (choices) {
					if (isCompact) {
						valHtml = jrhText.jrHtmlDisplayOptionListChoice(val, choices);
					} else {
						valHtml = jrhText.jrHtmlNiceOptionFromList(choices, val);
					}
				} else if (format === "textarea") {
					valHtml = jrhText.sanitizeUnsafeText(val, true, true);
				} else if (format === "checkbox") {
					// checkbox (note that we display null and undefined as false here)
					if (val) {
						valHtml = "true";
					} else {
						valHtml = "false";
					}
				} else if (format === "date") {
					// format as compact date?
					valHtml = jrhText.formatDateNicely(val, isCompact);
				}

				// fallback default
				if (valHtml === undefined) {
					// just coerce to a string for display
					valHtml = jrhText.sanitizeUnsafeText(jrhText.coerceToString(val, true), true, false);
				}

				// can we link to another object crud page for this field?
				if (!url &amp;&amp; val) {
					// this field refers to another model so we can link to it
					const refModelClass = this.getSchemaFieldVal(fieldName, "refModelClass");
					if (refModelClass) {
						url = refModelClass.getCrudUrlBase("view", val);
					}
				}
				// wrap in url?
				if (url) {
					valHtml = `&lt;a href="${url}">${valHtml}&lt;/a>`;
				}
			} else {
				// not read only, editable
				if (choices) {
					const flagShowBlank = true;
					valHtml = jrhText.jrHtmlFormOptionListSelect(fieldName, choices, val, flagShowBlank);
				} else if (format === "textarea") {
					// textview block (note in this case we pass false, false to sanitize, so that we edit "" if its undefined)
					val = jrhText.sanitizeUnsafeText(val, false, false);
					valHtml = `&lt;textarea name="${fieldName}" rows="4" cols="80">${val}&lt;/textarea>`;
				} else if (format === "checkbox") {
					// checkbox
					if (val) {
						extra = "checked";
					} else {
						extra = "";
					}
					valHtml = `&lt;input type="checkbox" name="${fieldName}" ${extra}>`;
					// add a hidden var to handle the cases where unchecked checkbox is not sent, stupid html form processing of checkboxes
					valHtml += `&lt;input type="hidden" name="${fieldName}_checkbox" value="true">`;
				}
				// fallback default - simple text input
				if (valHtml === undefined) {
					// just show text in input (note in this case we pass false, false to sanitize, so that we edit "" if its undefined)
					val = jrhText.sanitizeUnsafeText(jrhText.coerceToString(val, true), false, false);
					valHtml = `&lt;input type="text" name="${fieldName}" value="${val}" size="80"/>`;
				}
			}
		}

		return valHtml;
	}
	//---------------------------------------------------------------------------














}






// export the class as the sole export
module.exports = ModelBaseMongoose;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Sun Jun 21 2020 11:32:01 GMT-0500 (Central Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
